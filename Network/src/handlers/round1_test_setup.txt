#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#include "handlers/round1_test_setup.h"
#include "handlers/round1_handler.h"
#include "handlers/round2_handler.h"
#include "handlers/start_game_handler.h"
#include "handlers/session_manager.h"
#include "handlers/session_context.h"   // set_client_session
#include "handlers/match_manager.h"
#include "transport/socket_server.h"
#include "protocol/opcode.h"
#include "db/core/db_client.h"
#include <cjson/cJSON.h>

//==============================================================================
// HELPER: Send JSON response
//==============================================================================
static void send_json(int fd, MessageHeader *req, uint16_t cmd, const char *json) {
    size_t json_len = json ? strlen(json) : 0;
    size_t total = sizeof(MessageHeader) + json_len;
    char *buf = malloc(total);
    if (!buf) return;

    MessageHeader resp = {
        .magic    = htons(MAGIC_NUMBER),
        .version  = PROTOCOL_VERSION,
        .flags    = 0,
        .command  = htons(cmd ? cmd : req->command),
        .reserved = 0,
        .seq_num  = htonl(ntohl(req->seq_num)),
        .length   = htonl((uint32_t)json_len)
    };

    memcpy(buf, &resp, sizeof(MessageHeader));
    if (json_len > 0) {
        memcpy(buf + sizeof(MessageHeader), json, json_len);
    }

    send(fd, buf, total, 0);
    free(buf);
}

//==============================================================================
// TEST MODE CONFIGURATION
//==============================================================================
// Change this to test different modes:
// MODE_ELIMINATION = 0  -> Loại người thấp điểm nhất mỗi round
// MODE_SCORING = 1      -> Chỉ tính điểm, không loại
//==============================================================================
#define TEST_GAME_MODE MODE_SCORING  // <-- TESTING SCORING MODE NOW
//==============================================================================

static MatchState *g_test_match = NULL;

// Load MCQ questions from database
static int load_mcq_from_db(RoundState *round) {
    printf("[TestSetup] Loading MCQ questions from database...\n");
    
    cJSON *result = NULL;
    int rc = db_get("questions", "type=eq.MCQ&limit=3&order=id.asc", &result);
    
    if (rc != DB_OK || !result) {
        printf("[TestSetup] Failed to load questions from DB (rc=%d)\n", rc);
        return -1;
    }
    
    if (!cJSON_IsArray(result)) {
        printf("[TestSetup] Expected array from DB\n");
        cJSON_Delete(result);
        return -1;
    }
    
    int count = cJSON_GetArraySize(result);
    if (count == 0) {
        printf("[TestSetup] No MCQ questions found in database\n");
        cJSON_Delete(result);
        return -1;
    }
    
    printf("[TestSetup] Found %d MCQ questions\n", count);
    round->question_count = (count > 5) ? 5 : count;
    
    for (int i = 0; i < round->question_count; i++) {
        cJSON *q = cJSON_GetArrayItem(result, i);
        cJSON *id = cJSON_GetObjectItem(q, "id");
        cJSON *data = cJSON_GetObjectItem(q, "data");
        
        if (!id || !data) {
            printf("[TestSetup] Q%d: Missing id or data\n", i);
            continue;
        }
        
        // Get actual question ID from database
        round->questions[i].question_id = id->valueint;
        round->questions[i].status = QUESTION_PENDING;
        
        // Build question JSON for client
        cJSON *client_q = cJSON_CreateObject();
        cJSON_AddNumberToObject(client_q, "question_id", round->questions[i].question_id);
        
        cJSON *question_text = cJSON_GetObjectItem(data, "question");
        cJSON *choices = cJSON_GetObjectItem(data, "choices");
        cJSON *image = cJSON_GetObjectItem(data, "image");
        cJSON *correct_answer = cJSON_GetObjectItem(data, "correct_answer");
        
        if (question_text) cJSON_AddStringToObject(client_q, "question", question_text->valuestring);
        if (choices) cJSON_AddItemToObject(client_q, "choices", cJSON_Duplicate(choices, 1));
        if (image) cJSON_AddStringToObject(client_q, "image", image->valuestring);
        
        // Store correct_answer (numeric index) in question data for validation
        if (correct_answer && cJSON_IsNumber(correct_answer)) {
            cJSON_AddNumberToObject(client_q, "correct_answer", correct_answer->valueint);
            printf("[TestSetup] Q%d (id=%d): correct_answer = %d\n", 
                   i, round->questions[i].question_id, correct_answer->valueint);
        } else {
            printf("[TestSetup] Q%d: No correct_answer found, defaulting to 0\n", i);
            cJSON_AddNumberToObject(client_q, "correct_answer", 0);
        }
        
        char *json_str = cJSON_PrintUnformatted(client_q);
        if (json_str) {
            // Store in question_data array
            round->question_data[i].round = 1;
            round->question_data[i].index = i;
            round->question_data[i].json_data = strdup(json_str);
            free(json_str);
        }
        cJSON_Delete(client_q);
        
        printf("[TestSetup] Q%d loaded: id=%d\n", i, round->questions[i].question_id);
    }
    
    cJSON_Delete(result);
    printf("[TestSetup] Loaded %d questions successfully\n", round->question_count);
    return 0;
}

// Load BID questions from database for Round 2
static int load_bid_from_db(RoundState *round) {
    printf("[TestSetup] Loading BID questions from database...\n");
    
    cJSON *result = NULL;
    int rc = db_get("questions", "type=eq.bid&limit=5&order=id.asc", &result);
    
    if (rc != DB_OK || !result) {
        printf("[TestSetup] Failed to load BID questions from DB (rc=%d)\n", rc);
        return -1;
    }
    
    if (!cJSON_IsArray(result)) {
        printf("[TestSetup] Expected array from DB\n");
        cJSON_Delete(result);
        return -1;
    }
    
    int count = cJSON_GetArraySize(result);
    if (count == 0) {
        printf("[TestSetup] No BID questions found in database\n");
        cJSON_Delete(result);
        return -1;
    }
    
    printf("[TestSetup] Found %d BID questions\n", count);
    round->question_count = (count > 5) ? 5 : count;
    
    for (int i = 0; i < round->question_count; i++) {
        cJSON *q = cJSON_GetArrayItem(result, i);
        cJSON *id = cJSON_GetObjectItem(q, "id");
        cJSON *data = cJSON_GetObjectItem(q, "data");
        
        if (!id || !data) {
            printf("[TestSetup] BID Q%d: Missing id or data\n", i);
            continue;
        }
        
        round->questions[i].question_id = id->valueint;
        round->questions[i].status = QUESTION_PENDING;
        
        // Build question JSON for client
        cJSON *client_q = cJSON_CreateObject();
        cJSON_AddNumberToObject(client_q, "question_id", round->questions[i].question_id);
        
        cJSON *question_text = cJSON_GetObjectItem(data, "question");
        cJSON *correct_answer = cJSON_GetObjectItem(data, "correct_answer");
        cJSON *image = cJSON_GetObjectItem(data, "image");
        
        if (question_text) cJSON_AddStringToObject(client_q, "question", question_text->valuestring);
        if (image) cJSON_AddStringToObject(client_q, "image", image->valuestring);
        
        // Store correct_answer (numeric price) in question data for validation
        if (correct_answer && cJSON_IsNumber(correct_answer)) {
            cJSON_AddNumberToObject(client_q, "correct_answer", correct_answer->valueint);
            printf("[TestSetup] BID Q%d (id=%d): correct_price = %d\n", 
                   i, round->questions[i].question_id, correct_answer->valueint);
        }
        
        char *json_str = cJSON_PrintUnformatted(client_q);
        if (json_str) {
            round->question_data[i].round = 2;
            round->question_data[i].index = i;
            round->question_data[i].json_data = strdup(json_str);
            free(json_str);
        }
        cJSON_Delete(client_q);
        
        printf("[TestSetup] BID Q%d loaded: id=%d\n", i, round->questions[i].question_id);
    }
    
    cJSON_Delete(result);
    printf("[TestSetup] Loaded %d BID questions successfully\n", round->question_count);
    return 0;
}

MatchState* setup_test_match(void) {
    printf("\n");
    printf("==========================================================\n");
    printf("              SETTING UP TEST MATCH                       \n");
    printf("==========================================================\n");
    printf("  Match ID: %d\n", TEST_MATCH_ID);
    printf("  Mode: %s\n", TEST_GAME_MODE == MODE_ELIMINATION ? "ELIMINATION" : "SCORING");
    printf("  Players: 3 (account_id: 1, 2, 3)\n");
    printf("==========================================================\n\n");
    
    // Create match using match_manager
    g_test_match = match_create(TEST_MATCH_ID, TEST_MATCH_ID); // match_id = room_id = 999
    if (!g_test_match) {
        printf("[TestSetup] ERROR: Failed to create match\n");
        return NULL;
    }
    
    // Set game mode
    g_test_match->mode = TEST_GAME_MODE;
    printf("[TestSetup] Game mode set to: %s\n", 
           g_test_match->mode == MODE_ELIMINATION ? "ELIMINATION" : "SCORING");
    
    // Add 3 test players directly
    int32_t test_accounts[] = {1, 2, 3};
    for (int i = 0; i < 3; i++) {
        MatchPlayerState *mp = &g_test_match->players[i];
        mp->account_id = test_accounts[i];
        mp->match_player_id = 1000 + i;  // Fake ID for testing
        mp->score = 0;
        mp->score_delta = 0;
        mp->connected = 1;
        mp->eliminated = 0;
        mp->forfeited = 0;
        mp->eliminated_at_round = -1;
        printf("[TestSetup] Added player: account_id=%d, match_player_id=%d\n", 
               test_accounts[i], mp->match_player_id);
    }
    g_test_match->player_count = 3;
    
    // Setup Round 1 (MCQ)
    RoundState *round = &g_test_match->rounds[0];
    round->index = 0;
    round->type = ROUND_MCQ;
    round->status = ROUND_PENDING;
    round->current_question_idx = 0;
    round->started_at = 0;
    round->ended_at = 0;
    
    // Load questions from database
    if (load_mcq_from_db(round) != 0) {
        printf("[TestSetup] WARNING: Could not load from DB, using hardcoded questions\n");
        
        // Fallback to hardcoded questions
        round->question_count = 3;
        for (int i = 0; i < 3; i++) {
            round->questions[i].question_id = 1;
            round->questions[i].status = QUESTION_PENDING;
            
            round->question_data[i].round = 1;
            round->question_data[i].index = i;
            
            char *json = malloc(256);
            snprintf(json, 256,
                "{\"question_id\":%d,\"question\":\"Test Question %d?\","
                "\"choices\":[\"A\",\"B\",\"C\",\"D\"],\"correct_answer\":1}",
                round->questions[i].question_id, i + 1);
            round->question_data[i].json_data = json;
        }
    }
    
    // Setup Round 2 (BID)
    RoundState *round2 = &g_test_match->rounds[1];
    round2->index = 1;
    round2->type = ROUND_BID;
    round2->status = ROUND_PENDING;
    round2->current_question_idx = 0;
    round2->started_at = 0;
    round2->ended_at = 0;
    
    // Load BID questions from database
    if (load_bid_from_db(round2) != 0) {
        printf("[TestSetup] WARNING: Could not load BID from DB, using hardcoded questions\n");
        
        // Fallback to hardcoded questions
        round2->question_count = 3;
        for (int i = 0; i < 3; i++) {
            round2->questions[i].question_id = 2000 + i;
            round2->questions[i].status = QUESTION_PENDING;
            
            round2->question_data[i].round = 2;
            round2->question_data[i].index = i;
            
            char *json = malloc(256);
            int prices[] = {139, 99, 199};
            snprintf(json, 256,
                "{\"question_id\":%d,\"question\":\"What is the price of Product %d (USD)?\","
                "\"image\":\"/bg/iphone15.jpg\",\"correct_answer\":%d}",
                round2->questions[i].question_id, i + 1, prices[i]);
            round2->question_data[i].json_data = json;
        }
    }
    
    // Set current round - Change this to test different rounds:
    // 0 = Start at Round 1 (MCQ)
    // 1 = Start at Round 2 (BID) - Direct testing
    g_test_match->current_round_idx = 0;  // <-- TESTING ROUND 1
    g_test_match->round_count = 2;
    g_test_match->status = MATCH_PLAYING;
    
    printf("[TestSetup] Test match setup complete!\n");
    printf("[TestSetup] Starting at Round %d\n", g_test_match->current_round_idx + 1);
    printf("[TestSetup] Waiting for players to connect...\n\n");
    
    return g_test_match;
}

void print_test_match_state(void) {
    if (!g_test_match) {
        printf("[TestSetup] No test match exists\n");
        return;
    }
    
    printf("\n=== TEST MATCH STATE ===\n");
    printf("Match ID: %u (db: %lld)\n", g_test_match->runtime_match_id, 
           (long long)g_test_match->db_match_id);
    printf("Mode: %s\n", g_test_match->mode == MODE_ELIMINATION ? "ELIMINATION" : "SCORING");
    printf("Status: %d\n", g_test_match->status);
    printf("Current Round: %d/%d\n", g_test_match->current_round_idx + 1, g_test_match->round_count);
    printf("Players (%d):\n", g_test_match->player_count);
    
    for (int i = 0; i < g_test_match->player_count; i++) {
        MatchPlayerState *p = &g_test_match->players[i];
        printf("  [%d] account_id=%d score=%d eliminated=%d forfeited=%d connected=%d\n",
               i, p->account_id, p->score, p->eliminated, p->forfeited, p->connected);
    }
    
    RoundState *r = &g_test_match->rounds[g_test_match->current_round_idx];
    printf("Round %d: type=%d questions=%d current=%d\n",
           r->index + 1, r->type, r->question_count, r->current_question_idx);
    printf("========================\n\n");
}

void cleanup_test_match(void) {
    printf("[TestSetup] Cleaning up test match...\n");
    
    if (g_test_match) {
        // Free question data strings
        for (int r = 0; r < g_test_match->round_count; r++) {
            RoundState *round = &g_test_match->rounds[r];
            for (int q = 0; q < round->question_count; q++) {
                if (round->question_data[q].json_data) {
                    free(round->question_data[q].json_data);
                    round->question_data[q].json_data = NULL;
                }
            }
        }
        
        // Destroy match via manager
        match_destroy(g_test_match->runtime_match_id);
        g_test_match = NULL;
    }
    
    printf("[TestSetup] Cleanup complete\n");
}

void handle_test_login(int client_fd, MessageHeader *header, const char *payload) {
    if (header->length < 4) {
        printf("[TestLogin] Invalid payload length: %u\n", header->length);
        return;
    }
    
    int32_t account_id;
    memcpy(&account_id, payload, 4);
    account_id = ntohl(account_id);
    
    printf("[TestLogin] Test login request: account_id=%d, fd=%d\n", account_id, client_fd);
    
    // Validate account_id (1, 2, or 3 for testing)
    if (account_id < 1 || account_id > 3) {
        printf("[TestLogin] Invalid test account_id: %d (must be 1, 2, or 3)\n", account_id);
        
        cJSON *err = cJSON_CreateObject();
        cJSON_AddBoolToObject(err, "success", cJSON_False);
        cJSON_AddStringToObject(err, "error", "Invalid test account (use 1, 2, or 3)");
        char *json = cJSON_PrintUnformatted(err);
        send_json(client_fd, header, ERR_BAD_REQUEST, json);
        free(json);
        cJSON_Delete(err);
        return;
    }
    
    // Create session binding using session_context (for dispatcher auth check)
    // Use "TEST_" prefix to bypass DB validation in session_is_valid()
    char fake_session_id[37] = "TEST_PLAYER_X_SESSION_0000000000000";
    fake_session_id[12] = '0' + account_id;  // TEST_PLAYER_1_, TEST_PLAYER_2_, etc.
    
    // This binds the client_fd to account_id so require_auth will pass
    set_client_session(client_fd, fake_session_id, account_id);
    
    // Also create a UserSession entry for is_connected() to work
    // session_bind_after_login creates the UserSession and marks it as LOBBY
    UserSession *session = session_bind_after_login(client_fd, account_id, fake_session_id, header);
    if (session) {
        // Mark as playing so is_connected() returns true
        session_mark_playing(session);
        printf("[TestLogin] UserSession created and marked PLAYING: account_id=%d, fd=%d\n", 
               account_id, client_fd);
    } else {
        printf("[TestLogin] Warning: Could not create UserSession for account %d\n", account_id);
    }
    
    // Send success response with RES_LOGIN_OK opcode
    cJSON *resp = cJSON_CreateObject();
    cJSON_AddBoolToObject(resp, "success", cJSON_True);
    cJSON_AddNumberToObject(resp, "account_id", account_id);
    cJSON_AddNumberToObject(resp, "match_id", TEST_MATCH_ID);
    cJSON_AddStringToObject(resp, "mode", g_test_match ? 
        (g_test_match->mode == MODE_ELIMINATION ? "ELIMINATION" : "SCORING") : "UNKNOWN");
    cJSON_AddStringToObject(resp, "message", "Test login successful");
    
    char *json = cJSON_PrintUnformatted(resp);
    // Use CMD_TEST_LOGIN (0x0002) as response so frontend can catch it
    send_json(client_fd, header, CMD_TEST_LOGIN, json);
    free(json);
    cJSON_Delete(resp);
    
    printf("[TestLogin] Test login successful for account %d\n", account_id);
}
