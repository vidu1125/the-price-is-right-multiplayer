# Plan Tri·ªÉn Khai KICK_MEMBER

## üìã T·ªïng Quan

**M·ª•c ti√™u:** Tri·ªÉn khai t√≠nh nƒÉng kick member (ƒëu·ªïi ng∆∞·ªùi ch∆°i) kh·ªèi ph√≤ng ch·ªù

**Tham kh·∫£o ch√≠nh:** [handle_leave_room()](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Network/src/handlers/room_handler.c#625-815) (90% gi·ªëng nhau)

**ƒê·ªô ∆∞u ti√™n:** HIGH - T√≠nh nƒÉng c∆° b·∫£n cho host

---

## üéØ Y√™u C·∫ßu Ch·ª©c NƒÉng

### Ai ƒë∆∞·ª£c kick?
- ‚úÖ Ch·ªâ **host** m·ªõi ƒë∆∞·ª£c kick
- ‚úÖ Kick **b·∫•t k·ª≥ member n√†o** (tr·ª´ ch√≠nh m√¨nh)
- ‚úÖ Ch·ªâ kick khi ph√≤ng ƒëang **WAITING** (ch∆∞a b·∫Øt ƒë·∫ßu game)

### ƒêi·ªÅu g√¨ x·∫£y ra?
1. **Ng∆∞·ªùi b·ªã kick:**
   - B·ªã x√≥a kh·ªèi ph√≤ng
   - Quay v·ªÅ lobby
   - Nh·∫≠n th√¥ng b√°o "B·∫°n ƒë√£ b·ªã kick"

2. **Host:**
   - Nh·∫≠n x√°c nh·∫≠n kick th√†nh c√¥ng

3. **Ng∆∞·ªùi ch∆°i c√≤n l·∫°i:**
   - Th·∫•y th√¥ng b√°o "Player X ƒë√£ r·ªùi ph√≤ng"
   - Danh s√°ch ng∆∞·ªùi ch∆°i t·ª± ƒë·ªông c·∫≠p nh·∫≠t

---

## üì¶ C·∫•u Tr√∫c D·ªØ Li·ªáu

### 1. Payload t·ª´ Client ‚Üí Server

```c
typedef struct PACKED {
    uint32_t target_account_id;  // ID ng∆∞·ªùi b·ªã kick (network byte order)
} KickMemberPayload;
```

**K√≠ch th∆∞·ªõc:** 4 bytes

**‚ö†Ô∏è L∆ØU √ù:** 
- Code c≈© d√πng 8 bytes (room_id + target_id) - **SAI!**
- Spec ƒë√∫ng ch·ªâ c·∫ßn 4 bytes (target_account_id)
- Server t·ª± t√¨m room_id t·ª´ session

**‚ùì C√¢u h·ªèi: "Nh∆∞ng nh∆∞ v·∫≠y sao bi·∫øt x√≥a ng∆∞·ªùi ·ªü ph√≤ng n√†o?"**

**üí° Tr·∫£ l·ªùi:**

Server **KH√îNG C·∫¶N** client g·ª≠i `room_id` v√¨:

1. **Host ƒëang ·ªü trong ph√≤ng** ‚Üí Session c·ªßa host ƒë√£ l∆∞u th√¥ng tin n√†y
2. Server t√¨m room b·∫±ng c√°ch:
   ```c
   // L·∫•y account_id c·ªßa host t·ª´ session
   uint32_t kicker_id = session->account_id;
   
   // T√¨m room m√† host ƒëang ·ªü
   uint32_t room_id = room_find_by_player_account(kicker_id);
   ```

3. **L·ª£i √≠ch:**
   - ‚úÖ Payload nh·ªè h∆°n (4 bytes thay v√¨ 8 bytes)
   - ‚úÖ An to√†n h∆°n (client kh√¥ng th·ªÉ fake room_id)
   - ‚úÖ Server-authoritative (server quy·∫øt ƒë·ªãnh m·ªçi th·ª©)

**V√≠ d·ª•:**
```
Host (account_id=7) ƒëang ·ªü room 18
‚Üí G·ª≠i: {target_account_id: 8}
‚Üí Server t·ª± bi·∫øt: "account_id=7 ƒëang ·ªü room 18, mu·ªën kick account_id=8"
```

### 2. Response t·ª´ Server ‚Üí Host

```
RES_MEMBER_KICKED (0x00E1)
Payload: EMPTY (0 bytes)
```

### 3. Notification ƒë·∫øn ng∆∞·ªùi b·ªã kick

```
NTF_MEMBER_KICKED (0x02CA)
Payload: {"room_id": 123}
```

**‚ùì C√¢u h·ªèi: "Tri·ªÉn khai c√°i n√†y nh∆∞ n√†o?"**

**üí° Tr·∫£ l·ªùi: UNICAST - G·ª≠i cho 1 ng∆∞·ªùi c·ª• th·ªÉ**

**V·∫•n ƒë·ªÅ:** Kh√¥ng c√≥ helper function `room_send_to_player()` trong codebase!

**Gi·∫£i ph√°p:** G·ª≠i th·ªß c√¥ng nh∆∞ `LEAVE_ROOM` ƒë√£ l√†m:

```c
// B∆Ø·ªöC 1: T√¨m socket c·ªßa ng∆∞·ªùi b·ªã kick
UserSession *target_session = session_get_by_account(target_id);
int target_fd = -1;
if (target_session) {
    target_fd = target_session->socket_fd;
}

// B∆Ø·ªöC 2: T·∫°o JSON payload
cJSON *kick_json = cJSON_CreateObject();
cJSON_AddNumberToObject(kick_json, "room_id", room_id);
char *kick_str = cJSON_PrintUnformatted(kick_json);

// B∆Ø·ªöC 3: T·∫°o MessageHeader th·ªß c√¥ng
MessageHeader ntf;
memset(&ntf, 0, sizeof(ntf));
ntf.magic = htons(MAGIC_NUMBER);        // 0x4347 ("CG")
ntf.version = PROTOCOL_VERSION;         // 1
ntf.command = htons(NTF_MEMBER_KICKED); // 0x02CA
ntf.seq_num = 0;                        // Notification kh√¥ng c·∫ßn seq
ntf.length = htonl(strlen(kick_str));   // ƒê·ªô d√†i payload

// B∆Ø·ªöC 4: G·ª≠i header + payload
if (target_fd >= 0) {
    send(target_fd, &ntf, sizeof(ntf), 0);      // G·ª≠i header (16 bytes)
    send(target_fd, kick_str, strlen(kick_str), 0); // G·ª≠i payload
}

// B∆Ø·ªöC 5: Cleanup
free(kick_str);
cJSON_Delete(kick_json);
```

**T·∫°i sao ph·∫£i l√†m th·ªß c√¥ng?**
- [room_broadcast()](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Network/src/transport/room_manager.c#356-394) g·ª≠i cho **T·∫§T C·∫¢** ng∆∞·ªùi trong ph√≤ng
- `forward_response()` ch·ªâ d√πng cho **response**, kh√¥ng ph·∫£i notification
- C·∫ßn g·ª≠i cho **1 NG∆Ø·ªúI C·ª§ TH·ªÇ** (ng∆∞·ªùi b·ªã kick)

### 4. Notification ƒë·∫øn ng∆∞·ªùi ch∆°i c√≤n l·∫°i

```
NTF_PLAYER_LEFT (0x02BD)
Payload: {"account_id": 456}

NTF_PLAYER_LIST (0x02BE)
Payload: [{"account_id": 7, "name": "d1", "is_host": true, "is_ready": false}, ...]
### 4. Notification ƒë·∫øn ng∆∞·ªùi ch∆°i c√≤n l·∫°i

```
NTF_PLAYER_LEFT (0x02BD)
Payload: {"account_id": 456}

NTF_PLAYER_LIST (0x02BE)
Payload: [{"account_id": 7, "name": "d1", "is_host": true, "is_ready": false}, ...]
```

**‚ùì C√¢u h·ªèi: "Tri·ªÉn khai nh∆∞ n√†o?"**

**üí° Tr·∫£ l·ªùi: BROADCAST - G·ª≠i cho T·∫§T C·∫¢ ng∆∞·ªùi c√≤n l·∫°i**

**ƒêi·ªÉm quan tr·ªçng:** Ph·∫£i x√≥a ng∆∞·ªùi b·ªã kick kh·ªèi room **TR∆Ø·ªöC KHI** broadcast!

```c
// ========== QUAN TR·ªåNG: X√ìA TR∆Ø·ªöC ==========
// X√≥a ng∆∞·ªùi b·ªã kick kh·ªèi in-memory
room_remove_player(room_id, target_id);

// B√¢y gi·ªù room ch·ªâ c√≤n nh·ªØng ng∆∞·ªùi KH√îNG b·ªã kick
// ‚Üí Broadcast s·∫Ω KH√îNG g·ª≠i cho ng∆∞·ªùi b·ªã kick!

// ========== BROADCAST 1: NTF_PLAYER_LEFT ==========
// Th√¥ng b√°o "Player X ƒë√£ r·ªùi ph√≤ng"
cJSON *left_json = cJSON_CreateObject();
cJSON_AddNumberToObject(left_json, "account_id", target_id);
char *left_str = cJSON_PrintUnformatted(left_json);

// G·ª≠i cho T·∫§T C·∫¢ ng∆∞·ªùi c√≤n l·∫°i trong room
room_broadcast(room_id, NTF_PLAYER_LEFT, left_str, strlen(left_str), -1);
//                                                                      ^^
//                                                                      -1 = kh√¥ng exclude ai

free(left_str);
cJSON_Delete(left_json);

// ========== BROADCAST 2: NTF_PLAYER_LIST ==========
// C·∫≠p nh·∫≠t danh s√°ch ƒë·∫ßy ƒë·ªß
broadcast_player_list(room_id);
```

**C√°ch `room_broadcast()` ho·∫°t ƒë·ªông:**

```c
void room_broadcast(int room_id, uint16_t command, 
                   const char *payload, uint32_t payload_len, 
                   int exclude_fd) {
    RoomState *room = find_room(room_id);
    
    // Duy·ªát qua T·∫§T C·∫¢ member trong room
    for (int i = 0; i < room->member_count; i++) {
        int fd = room->member_fds[i];
        
        // B·ªè qua n·∫øu l√† exclude_fd
        if (fd == exclude_fd) continue;
        
        // G·ª≠i cho member n√†y
        send(fd, &header, sizeof(header), 0);
        send(fd, payload, payload_len, 0);
    }
}
```

**T·∫°i sao ph·∫£i x√≥a TR∆Ø·ªöC KHI broadcast?**

```
‚ùå SAI (broadcast tr∆∞·ªõc):
1. room c√≥: [player1, player2, player3_b·ªã_kick]
2. Broadcast ‚Üí T·∫§T C·∫¢ 3 ng∆∞·ªùi nh·∫≠n ƒë∆∞·ª£c
3. X√≥a player3
‚Üí Player3 v·ª´a b·ªã kick V·ª™A nh·∫≠n th√¥ng b√°o "b·∫°n b·ªã kick" (l·ªói!)

‚úÖ ƒê√öNG (x√≥a tr∆∞·ªõc):
1. room c√≥: [player1, player2, player3_b·ªã_kick]
2. X√≥a player3 ‚Üí room c√≤n: [player1, player2]
3. Broadcast ‚Üí CH·ªà player1 v√† player2 nh·∫≠n ƒë∆∞·ª£c
‚Üí Player3 KH√îNG nh·∫≠n broadcast n√†y (ƒë√∫ng!)
```

**C√°ch `broadcast_player_list()` ho·∫°t ƒë·ªông:**

```c
void broadcast_player_list(uint32_t room_id) {
    RoomState *room = find_room(room_id);
    
    // T·∫°o JSON array ch·ª©a T·∫§T C·∫¢ players hi·ªán t·∫°i
    cJSON *members = cJSON_CreateArray();
    for (int i = 0; i < room->player_count; i++) {
        cJSON *member = cJSON_CreateObject();
        cJSON_AddNumberToObject(member, "account_id", room->players[i].account_id);
        cJSON_AddStringToObject(member, "name", room->players[i].name);
        cJSON_AddStringToObject(member, "avatar", room->players[i].avatar);
        cJSON_AddBoolToObject(member, "is_host", room->players[i].is_host);
        cJSON_AddBoolToObject(member, "is_ready", room->players[i].is_ready);
        cJSON_AddItemToArray(members, member);
    }
    
    // Broadcast cho T·∫§T C·∫¢
    room_broadcast(room_id, NTF_PLAYER_LIST, json_str, strlen(json_str), -1);
}
```

---

## üîß Backend Implementation

### File: `room_handler.c`

#### B∆∞·ªõc 1: Th√™m Payload Struct (Line ~46)

```c
typedef struct PACKED {
    uint32_t target_account_id; // network byte order
} KickMemberPayload;
```

#### B∆∞·ªõc 2: Implement `handle_kick_member()` (Lines 569-623)

**Thay th·∫ø stub hi·ªán t·∫°i b·∫±ng:**

```c
void handle_kick_member(int client_fd, MessageHeader *req, const char *payload) {
    printf("[HANDLER] <KICK_MEMBER> Request from fd=%d\n", client_fd);
    
    // ========== B∆Ø·ªöC 1: VALIDATE PAYLOAD ==========
    if (req->length != sizeof(KickMemberPayload)) {
        send_error(client_fd, req, ERR_BAD_REQUEST, "Invalid payload");
        return;
    }
    
    // ========== B∆Ø·ªöC 2: PARSE PAYLOAD ==========
    KickMemberPayload data;
    memcpy(&data, payload, sizeof(data));
    uint32_t target_id = ntohl(data.target_account_id);
    
    printf("[Kick Member] Target account_id: %u\n", target_id);
    
    // ========== B∆Ø·ªöC 3: VALIDATE SESSION ==========
    UserSession *session = session_get_by_socket(client_fd);
    if (!session || session->state != SESSION_LOBBY) {
        send_error(client_fd, req, ERR_NOT_LOGGED_IN, "Not logged in");
        return;
    }
    
    uint32_t kicker_id = session->account_id;
    printf("[Kick Member] Kicker account_id: %u\n", kicker_id);
    
    // ========== B∆Ø·ªöC 4: T√åM ROOM ==========
    uint32_t room_id = room_find_by_player_account(kicker_id);
    if (room_id == 0) {
        send_error(client_fd, req, ERR_BAD_REQUEST, "Not in any room");
        return;
    }
    
    RoomState *room = room_get_state(room_id);
    if (!room) {
        send_error(client_fd, req, ERR_BAD_REQUEST, "Room not found");
        return;
    }
    
    printf("[Kick Member] Room ID: %u\n", room_id);
    
    // ========== B∆Ø·ªöC 5: VALIDATE HOST PERMISSION ==========
    if (room->host_id != kicker_id) {
        send_error(client_fd, req, ERR_NOT_HOST, "Only host can kick members");
        return;
    }
    
    // ========== B∆Ø·ªöC 6: VALIDATE ROOM STATUS ==========
    if (room->status != ROOM_WAITING) {
        send_error(client_fd, req, ERR_BAD_REQUEST, "Cannot kick during game");
        return;
    }
    
    // ========== B∆Ø·ªöC 7: VALIDATE TARGET T·ªíN T·∫†I ==========
    int target_index = -1;
    for (int i = 0; i < room->player_count; i++) {
        if (room->players[i].account_id == target_id) {
            target_index = i;
            break;
        }
    }
    
    if (target_index == -1) {
        send_error(client_fd, req, ERR_BAD_REQUEST, "Target player not in room");
        return;
    }
    
    // ========== B∆Ø·ªöC 8: KH√îNG TH·ªÇ KICK CH√çNH M√åNH ==========
    if (target_id == kicker_id) {
        send_error(client_fd, req, ERR_BAD_REQUEST, "Cannot kick yourself");
        return;
    }
    
    // ========== LOG BEFORE STATE ==========
    printf("[Kick Member] ===== BEFORE STATE =====\n");
    printf("[Kick Member] [RoomState] Room ID: %u\n", room->id);
    printf("[Kick Member] [RoomState] Host ID: %u\n", room->host_id);
    printf("[Kick Member] [RoomState] Player Count: %d\n", room->player_count);
    printf("[Kick Member] [RoomPlayerState] Players:\n");
    for (int i = 0; i < room->player_count; i++) {
        printf("[Kick Member] [RoomPlayerState]   [%d] %s (id=%u, host=%s, ready=%s, connected=%s)\n",
               i, room->players[i].name, room->players[i].account_id,
               room->players[i].is_host ? "YES" : "NO",
               room->players[i].is_ready ? "YES" : "NO",
               room->players[i].connected ? "YES" : "NO");
    }
    printf("[Kick Member] Kicker: %u (host)\n", kicker_id);
    printf("[Kick Member] Target: %u\n", target_id);
    
    // ========== B∆Ø·ªöC 9: T√åM TARGET SESSION V√Ä SOCKET ==========
    UserSession *target_session = session_get_by_account(target_id);
    int target_fd = -1;
    if (target_session) {
        target_fd = target_session->socket_fd;
        printf("[Kick Member] Target socket fd: %d\n", target_fd);
    } else {
        printf("[Kick Member] ‚ö†Ô∏è  Target session not found (offline?)\n");
    }
    
    // ========== B∆Ø·ªöC 10: X√ìA KH·ªéI IN-MEMORY (QUAN TR·ªåNG: PH·∫¢I TR∆Ø·ªöC KHI BROADCAST!) ==========
    int removed = room_remove_player(room_id, target_id);
    if (removed != 0) {
        send_error(client_fd, req, ERR_BAD_REQUEST, "Failed to remove player");
        return;
    }
    
    printf("[Kick Member] ‚úÖ Removed player %u from in-memory state\n", target_id);
    
    // ========== B∆Ø·ªöC 11: X√ìA KH·ªéI DATABASE ==========
    int rc = room_repo_remove_player(room_id, target_id);
    if (rc != 0) {
        printf("[Kick Member] ‚ö†Ô∏è  Warning: Failed to remove from DB\n");
    }
    
    // ========== B∆Ø·ªöC 12: C·∫¨P NH·∫¨T TARGET SESSION STATE ==========
    if (target_session) {
        target_session->state = SESSION_LOBBY;
        printf("[Kick Member] Updated target session state to SESSION_LOBBY\n");
    }
    
    // ========== LOG AFTER STATE ==========
    printf("[Kick Member] ===== AFTER STATE =====\n");
    printf("[Kick Member] [RoomState] Room ID: %u\n", room->id);
    printf("[Kick Member] [RoomState] Player Count: %d\n", room->player_count);
    printf("[Kick Member] [RoomPlayerState] Players:\n");
    for (int i = 0; i < room->player_count; i++) {
        printf("[Kick Member] [RoomPlayerState]   [%d] %s (id=%u, host=%s, ready=%s, connected=%s)\n",
               i, room->players[i].name, room->players[i].account_id,
               room->players[i].is_host ? "YES" : "NO",
               room->players[i].is_ready ? "YES" : "NO",
               room->players[i].connected ? "YES" : "NO");
    }
    
    // ========== B∆Ø·ªöC 13: G·ª¨I RESPONSE CHO HOST ==========
    forward_response(client_fd, req, RES_MEMBER_KICKED, "", 0);
    printf("[Kick Member] Sent RES_MEMBER_KICKED to host (fd=%d)\n", client_fd);
    
    // ========== B∆Ø·ªöC 14: G·ª¨I NTF_MEMBER_KICKED CHO NG∆Ø·ªúI B·ªä KICK (UNICAST) ==========
    if (target_fd >= 0) {
        cJSON *kick_json = cJSON_CreateObject();
        cJSON_AddNumberToObject(kick_json, "room_id", room_id);
        char *kick_str = cJSON_PrintUnformatted(kick_json);
        
        // Manual send (v√¨ kh√¥ng c√≥ helper function cho unicast)
        MessageHeader ntf;
        memset(&ntf, 0, sizeof(ntf));
        ntf.magic = htons(MAGIC_NUMBER);
        ntf.version = PROTOCOL_VERSION;
        ntf.command = htons(NTF_MEMBER_KICKED);
        ntf.seq_num = 0;
        ntf.length = htonl(strlen(kick_str));
        
        send(target_fd, &ntf, sizeof(ntf), 0);
        send(target_fd, kick_str, strlen(kick_str), 0);
        
        free(kick_str);
        cJSON_Delete(kick_json);
        
        printf("[Kick Member] Sent NTF_MEMBER_KICKED to target (fd=%d)\n", target_fd);
    }
    
    // ========== B∆Ø·ªöC 15: BROADCAST NTF_PLAYER_LEFT CHO NG∆Ø·ªúI CH∆†I C√íN L·∫†I ==========
    // (Target ƒë√£ b·ªã x√≥a, n√™n s·∫Ω kh√¥ng nh·∫≠n broadcast n√†y)
    cJSON *left_json = cJSON_CreateObject();
    cJSON_AddNumberToObject(left_json, "account_id", target_id);
    char *left_str = cJSON_PrintUnformatted(left_json);
    
    printf("[Kick Member] Broadcasting NTF_PLAYER_LEFT: %s\n", left_str);
    room_broadcast(room_id, NTF_PLAYER_LEFT, left_str, strlen(left_str), -1);
    
    free(left_str);
    cJSON_Delete(left_json);
    
    // ========== B∆Ø·ªöC 16: BROADCAST NTF_PLAYER_LIST CHO NG∆Ø·ªúI CH∆†I C√íN L·∫†I ==========
    printf("[Kick Member] Broadcasting NTF_PLAYER_LIST\n");
    broadcast_player_list(room_id);
    
    printf("[Kick Member] ‚úÖ SUCCESS: player %u kicked from room %u by host %u\n",
           target_id, room_id, kicker_id);
}
```

#### B∆∞·ªõc 3: Verify Dispatcher (Line 93-94)

**‚úÖ ƒê√É C√ì S·∫¥N:**
```c
case CMD_KICK:
    handle_kick_member(client_fd, header, payload);
    break;
```

---

## üé® Frontend Implementation

### File: `hostService.js`

#### S·ª≠a Function `kickMember()` (Lines 204-213)

**‚ùå Code hi·ªán t·∫°i (SAI):**
```javascript
export function kickMember(roomId, targetId) {
    const buffer = new ArrayBuffer(8);  // SAI: 8 bytes
    const view = new DataView(buffer);
    
    view.setUint32(0, roomId, false);   // SAI: kh√¥ng c·∫ßn room_id
    view.setUint32(4, targetId, false);
    
    sendPacket(OPCODE.CMD_KICK, buffer);
}
```

**‚úÖ Code ƒë√∫ng:**
```javascript
/**
 * Kick m·ªôt member kh·ªèi ph√≤ng (ch·ªâ host)
 * KickMemberPayload struct (4 bytes):
 * - uint32_t target_account_id (network byte order)
 */
export function kickMember(targetAccountId) {
    console.log('[HOST_SERVICE] Kicking member:', targetAccountId);
    
    const buffer = new ArrayBuffer(4);  // ‚úÖ 4 bytes
    const view = new DataView(buffer);
    view.setUint32(0, targetAccountId, false);  // ‚úÖ Ch·ªâ target_account_id
    
    sendPacket(OPCODE.CMD_KICK, buffer);
}
```

#### S·ª≠a Handler `RES_MEMBER_KICKED` (Lines 215-231)

**‚ùå Code hi·ªán t·∫°i (SAI):**
```javascript
registerHandler(OPCODE.RES_MEMBER_KICKED, (payload) => {
    const text = new TextDecoder().decode(payload);
    let jsonStr = text.substring(text.indexOf('\r\n\r\n') + 4);
    
    try {
        const response = JSON.parse(jsonStr);  // SAI: payload r·ªóng!
        
        if (response.success) {
            console.log('[Host] Member kicked');
            alert('Member kicked successfully');
        } else {
            alert('Failed to kick member: ' + response.error);
        }
    } catch (e) {
        console.error('[Host] Parse error:', e);
    }
});
```

**‚úÖ Code ƒë√∫ng:**
```javascript
registerHandler(OPCODE.RES_MEMBER_KICKED, (payload) => {
    console.log('[HOST_SERVICE] ‚úÖ Member kicked successfully');
    // Payload r·ªóng, kh√¥ng c·∫ßn parse
    // UI s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t qua NTF_PLAYER_LEFT v√† NTF_PLAYER_LIST
});
```

### File: `WaitingRoom.js`

#### Th√™m Handler `NTF_MEMBER_KICKED` (sau line ~140)

```javascript
// Handler for NTF_MEMBER_KICKED (ch·ªâ ng∆∞·ªùi b·ªã kick nh·∫≠n ƒë∆∞·ª£c)
registerHandler(OPCODE.NTF_MEMBER_KICKED, (payload) => {
    const text = new TextDecoder().decode(payload);
    try {
        const { room_id } = JSON.parse(text);
        console.log('[WaitingRoom] ‚ùå You were kicked from room:', room_id);
        
        alert('‚ö†Ô∏è B·∫°n ƒë√£ b·ªã kick kh·ªèi ph√≤ng!');
        
        // Quay v·ªÅ lobby
        navigate('/lobby');
    } catch (e) {
        console.error('[WaitingRoom] Failed to parse NTF_MEMBER_KICKED:', e);
    }
});
```

### File: `MemberListPanel.js`

#### S·ª≠a Function Call `handleKick()` (Line 38)

**‚ùå Code hi·ªán t·∫°i (SAI):**
```javascript
const handleKick = (memberId) => {
    if (!window.confirm("Are you sure you want to kick this member?")) {
        return;
    }
    console.log("üîµ Kicking member:", memberId, "from room:", roomId);
    kickMember(roomId, memberId);  // SAI: 2 tham s·ªë
};
```

**‚úÖ Code ƒë√∫ng:**
```javascript
const handleKick = (memberId) => {
    if (!window.confirm("B·∫°n c√≥ ch·∫Øc mu·ªën kick ng∆∞·ªùi ch∆°i n√†y?")) {
        return;
    }
    console.log("üîµ Kicking member:", memberId);
    kickMember(memberId);  // ‚úÖ Ch·ªâ 1 tham s·ªë
};
```

---

## ‚ö†Ô∏è Nh·ªØng ƒêi·ªÉm C·ª±c K·ª≥ Quan Tr·ªçng

### 1. **Th·ª© T·ª± Th·ª±c Hi·ªán PH·∫¢I ƒê√öNG**

```
‚úÖ ƒê√öNG:
1. X√≥a kh·ªèi in-memory (room_remove_player)
2. X√≥a kh·ªèi DB (room_repo_remove_player)
3. C·∫≠p nh·∫≠t session
4. G·ª≠i response cho host
5. G·ª≠i notification cho ng∆∞·ªùi b·ªã kick
6. Broadcast cho ng∆∞·ªùi c√≤n l·∫°i

‚ùå SAI:
- N·∫øu broadcast TR∆Ø·ªöC KHI x√≥a ‚Üí ng∆∞·ªùi b·ªã kick s·∫Ω nh·∫≠n ƒë∆∞·ª£c broadcast!
```

### 2. **Payload Size**

```
‚ùå SAI: 8 bytes (room_id + target_id)
‚úÖ ƒê√öNG: 4 bytes (ch·ªâ target_account_id)
```

### 3. **Unicast vs Broadcast**

- **Unicast** (g·ª≠i cho 1 ng∆∞·ªùi): D√πng manual [send()](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Network/src/handlers/room_handler.c#65-71) v·ªõi `MessageHeader`
- **Broadcast** (g·ª≠i cho nhi·ªÅu ng∆∞·ªùi): D√πng [room_broadcast()](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Network/src/transport/room_manager.c#356-394)

### 4. **Logging**

Ph·∫£i log ƒë·∫ßy ƒë·ªß:
- BEFORE state (tr∆∞·ªõc khi kick)
- AFTER state (sau khi kick)
- M·ªói b∆∞·ªõc quan tr·ªçng

---

## ‚úÖ Checklist Tri·ªÉn Khai

### Backend

- [ ] **File: [room_handler.c](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Network/src/handlers/room_handler.c)**
  - [ ] Th√™m `KickMemberPayload` struct (line ~46)
  - [ ] Thay th·∫ø stub [handle_kick_member()](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Network/src/handlers/room_handler.c#569-624) (lines 569-623)
  - [ ] Verify includes: `<stdlib.h>`, `<string.h>`, `cJSON`
  
- [ ] **File: [dispatcher.c](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Network/src/handlers/dispatcher.c)**
  - [x] Verify `CMD_KICK` ƒë√£ registered (line 93-94) ‚úÖ **ƒê√É C√ì**

- [ ] **Build & Test**
  - [ ] Compile th√†nh c√¥ng
  - [ ] Kh√¥ng c√≥ warning

### Frontend

- [ ] **File: [hostService.js](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Frontend/src/services/hostService.js)**
  - [ ] S·ª≠a [kickMember()](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Frontend/src/services/hostService.js#199-214) function (lines 204-213)
    - [ ] ƒê·ªïi payload t·ª´ 8 bytes ‚Üí 4 bytes
    - [ ] X√≥a parameter `roomId`
    - [ ] Ch·ªâ gi·ªØ `targetAccountId`
  - [ ] S·ª≠a `RES_MEMBER_KICKED` handler (lines 215-231)
    - [ ] X√≥a JSON parsing
    - [ ] Ch·ªâ log success

- [ ] **File: [WaitingRoom.js](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Frontend/src/components/Room/WaitingRoom/WaitingRoom.js)**
  - [ ] Th√™m `NTF_MEMBER_KICKED` handler (sau line ~140)
    - [ ] Parse `room_id` t·ª´ payload
    - [ ] Show alert
    - [ ] Navigate to `/lobby`

- [ ] **File: [MemberListPanel.js](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Frontend/src/components/Room/WaitingRoom/MemberListPanel.js)**
  - [ ] S·ª≠a [handleKick()](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Frontend/src/components/Room/WaitingRoom/MemberListPanel.js#33-40) call (line 38)
    - [ ] X√≥a parameter `roomId`
    - [ ] Ch·ªâ truy·ªÅn `memberId`

### Testing

- [ ] **Test Case 1: Kick th√†nh c√¥ng**
  - [ ] Host kick member ‚Üí member b·ªã ƒëu·ªïi
  - [ ] Member nh·∫≠n th√¥ng b√°o "B·∫°n ƒë√£ b·ªã kick"
  - [ ] Member quay v·ªÅ lobby
  - [ ] Danh s√°ch ng∆∞·ªùi ch∆°i c·∫≠p nh·∫≠t

- [ ] **Test Case 2: Kh√¥ng ph·∫£i host**
  - [ ] Member th∆∞·ªùng click kick ‚Üí L·ªói "Only host can kick"

- [ ] **Test Case 3: Kick ch√≠nh m√¨nh**
  - [ ] Host kick ch√≠nh m√¨nh ‚Üí L·ªói "Cannot kick yourself"

- [ ] **Test Case 4: Kick khi ƒëang ch∆°i**
  - [ ] Game ƒë√£ b·∫Øt ƒë·∫ßu ‚Üí L·ªói "Cannot kick during game"

- [ ] **Test Case 5: Target kh√¥ng t·ªìn t·∫°i**
  - [ ] Kick ID kh√¥ng c√≥ trong ph√≤ng ‚Üí L·ªói "Target not in room"

---

## üöÄ Th·ª© T·ª± Th·ª±c Hi·ªán

1. **Backend tr∆∞·ªõc** (quan tr·ªçng h∆°n)
   - Th√™m struct
   - Implement handler
   - Build & test

2. **Frontend sau**
   - Fix payload
   - Fix handlers
   - Test UI

3. **Integration test**
   - Test to√†n b·ªô flow
   - Verify logs
   - Fix bugs n·∫øu c√≥

---

## üìù Notes

- Tham kh·∫£o [handle_leave_room()](file:///home/duyen/DAIHOC/NetworkProgramming/Final/the-price-is-right-multiplayer/Network/src/handlers/room_handler.c#625-815) khi g·∫∑p kh√≥ khƒÉn
- Logging ph·∫£i chi ti·∫øt ƒë·ªÉ d·ªÖ debug
- Test t·ª´ng b∆∞·ªõc, ƒë·ª´ng l√†m h·∫øt r·ªìi m·ªõi test
- N·∫øu c√≥ l·ªói, check logs backend tr∆∞·ªõc

